/**
 * Core Philosophy: This ruleset enforces a strict Role-Based Access Control (RBAC) model.
 * There are two primary roles: 'admin' and 'manager'. Admins have global read/write
 * access to all data, providing oversight and management capabilities. Managers have
 * scoped access, limited to the specific projects they are assigned to. Regular users
 * can only manage their own user profile. The default security posture is to deny all
 * access unless explicitly granted.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles, including their role.
 * - /projects/{projectId}: Top-level collection for projects. Each project document
 *   contains an 'assignedManagerId' field to link it to a manager.
 * - /projects/{projectId}/*: Subcollections for project-specific data like
 *   transactions, tasks, and attendance. Access to these is inherited from the
 *   parent project's ownership.
 * - /workers/{workerId}: A collection for worker profiles, managed exclusively by admins.
 * - /roles_admin/{userId}: A dedicated collection used for efficient, high-performance
 *   admin role checks. A user is an admin if a document with their UID exists here.
 *
 * Key Security Decisions:
 * - Admin Privilege: Admin status is determined by the existence of a document in the
 *   `/roles_admin` collection. This is a highly performant and secure pattern for
 *   checking global roles.
 * - Manager Scope: A manager's access is strictly tied to the `assignedManagerId`
 *   field on a project document. They cannot see or modify projects they do not manage.
 * - User Data Privacy: Users can only read and write their own document in the `/users`
 *   collection. Listing all users is forbidden for non-admins.
 * - Client-Side Writes to Roles: To prevent privilege escalation, the `/roles_admin`
 *   collection is read-only from the client. Role assignments must be handled by a
 *   trusted server-side process.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the authenticated user's UID matches the provided userId.
     * Used to verify resource ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    /**
     * Returns true if the document being accessed already exists.
     * CRITICAL for safe update and delete operations.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Checks for admin privileges by verifying the existence of a document
     * in the dedicated roles_admin collection. This is a highly performant
     * way to check for a global role.
     */
    function isAdmin() {
      // In a real app, this might be a custom claim, but for simplicity we'll check a field in the user's doc.
      // NOTE: This requires a read to the user's own doc, which is usually fine.
      // For higher security/performance, use custom claims or a separate roles collection.
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    /**
     * Checks if the current user is assigned as the manager for a specific project.
     * This requires reading the parent project document.
     */
    function isAssignedManager(projectId) {
      let project = get(/databases/$(database)/documents/projects/$(projectId));
      return isSignedIn() && project.data.assigned_manager_id == request.auth.uid;
    }

    /**
     * Validates that the projectId in a subcollection document's body matches
     * the projectId from the document's path.
     */
    function isProjectIdConsistent(projectId) {
      return request.resource.data.project_id == projectId;
    }
    
    /**
     * Enforces immutability of the projectId field on update to maintain
     * relational integrity.
     */
    function isProjectIdImmutable() {
      return request.resource.data.project_id == resource.data.project_id;
    }

    // -------------------------------------------------------------------------
    // Collection Rules
    // -------------------------------------------------------------------------

    /**
     * @description Manages user profiles. Users can create their own profile and read/update it.
     *              The 'role' field is immutable for non-admins to prevent privilege escalation.
     *              Admins have full read/write access.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isOwner(userId);
      allow update: if (isOwner(userId) && request.resource.data.role == resource.data.role) || isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Manages projects. Admins have full access. Managers can read projects
     *              they are assigned to. Only Admins can create, update, or delete projects.
     */
    match /projects/{projectId} {
      allow get: if isAdmin() || isAssignedManager(projectId);
      allow list: if isAdmin() || (isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/users/$(request.auth.uid)).data.assigned_project_ids);
      allow create, update, delete: if isAdmin();
    }

    /**
     * @description Stores transactions. Access is inherited from the parent project.
     *              Assigned managers can create transactions. Only admins can delete.
     */
    match /projects/{projectId}/transactions/{transactionId} {
      allow get, list: if isAdmin() || isAssignedManager(projectId);
      allow create: if (isAdmin() || isAssignedManager(projectId)) && isProjectIdConsistent(projectId);
      allow update: if isAdmin(); // Managers cannot edit transactions
      allow delete: if isAdmin();
    }

    /**
     * @description Stores tasks. Access is inherited from the parent project.
     *              Assigned managers can create and update tasks. Only admins can delete.
     */
    match /projects/{projectId}/tasks/{taskId} {
      allow get, list: if isAdmin() || isAssignedManager(projectId);
      allow create: if (isAdmin() || isAssignedManager(projectId)) && isProjectIdConsistent(projectId);
      allow update: if (isAdmin() || isAssignedManager(projectId)) && isProjectIdImmutable();
      allow delete: if isAdmin();
    }

    /**
     * @description Stores attendance. A composite key on worker_id and date must be
     *              enforced by the application logic, but rules secure access.
     *              Managers can create attendance records for their projects.
     */
    match /attendance/{attendanceId} {
        allow get, list: if isAdmin() || isAssignedManager(resource.data.project_id);
        allow create: if (isAdmin() || isAssignedManager(request.resource.data.project_id));
        allow update, delete: if isAdmin();
    }
    
    /**
     * @description Manages worker profiles. This data is global.
     *              Only administrators can create, update, or delete workers.
     *              Managers can read the list of workers to mark attendance.
     */
    match /workers/{workerId} {
      allow get, list: if isSignedIn(); // Allow all signed-in users to read worker data
      allow create, update, delete: if isAdmin();
    }
  }
}
